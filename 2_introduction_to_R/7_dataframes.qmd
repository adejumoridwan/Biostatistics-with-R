---
title: "DataFrames"
author: "Adejumo Ridwan Suleiman"
output: html_document
---

### Vectors and data frames
Almost invariably, you'll deal with more than one figure at a time in your analyses. For instance, we may have a list of the ages of customers at a bookstore:

$$28, 48, 47, 71, 22, 80, 48, 30, 31$$
Of course, we could store each observation in a separate variable:

```{r eval=FALSE}
age_person_1 <- 28
age_person_2 <- 48
age_person_3 <- 47
# ...and so on
```

...but this quickly becomes awkward. A much better solution is to store the entire list in just one variable. In R, such a list is called a _vector_. We can create a vector using the following code, where `c` stands for _combine_:

```{r eval=FALSE}
age <- c(28, 48, 47, 71, 22, 80, 48, 30, 31)
```

The numbers in the vector are called _elements_. We can treat the vector variable `age` just as we treated variables containing a single number. The difference is that the operations will apply to all elements in the list. So for instance, if we wish to express the ages in months rather than years, we can convert all ages to months using:

```{r eval=FALSE}
age_months <- age * 12
```

Most of the time, data will contain measurements of more than one quantity. In the case of our bookstore customers, we also have information about the amount of money they spent on their last purchase:

$$20, 59, 2, 12, 22, 160, 34, 34, 29$$

First, let's store this data in a vector:

```{r eval=FALSE}
purchase <- c(20, 59, 2, 12, 22, 160, 34, 34, 29)
```

It would be nice to combine these two vectors into a table, like we would do in a spreadsheet software such as Excel. That would allow us to look at relationships between the two vectors - perhaps we could find some interesting patterns? In R, tables of vectors are called _data frames_. We can combine the two vectors into a data frame as:

```{r eval=FALSE}
bookstore <- data.frame(age, purchase)
```

If you type `bookstore` into the Console, it will show a simply formatted table with the values of the two vectors (and row numbers):

```{r eval=FALSE}
> bookstore
  age purchase
1  28       20
2  48       59
3  47        2
4  71       12
5  22       22
6  80      160
7  48       34
8  30       34
9  31       29
```

A better way to look at the table may be to click on the variable name `bookstore` in the Environment panel, which will open the data frame in a spreadsheet format.

You will have noticed that R tends to print a `[1]` at the beginning of the line when we ask it to print the value of a variable:

```{r eval=FALSE}
> age
[1] 28 48 47 71 22 80 48 30 31
```

Why? Well, let's see what happens if we print a longer vector:

```{r eval=FALSE}
# When we enter data into a vector, we can put line breaks between
# the commas:
distances <- c(687, 5076, 7270, 967, 6364, 1683, 9394, 5712, 5206,
               4317, 9411, 5625, 9725, 4977, 2730, 5648, 3818, 8241,
               5547, 1637, 4428, 8584, 2962, 5729, 5325, 4370, 5989,
               9030, 5532, 9623)
distances
```

Depending on the size of your Console panel, R will require a different number of rows to display the data in `distances`. The output will look something like this:
```{r eval=FALSE}
> distances
 [1]  687 5076 7270  967 6364 1683 9394 5712 5206 4317 9411 5625 9725
[14] 4977 2730 5648 3818 8241 5547 1637 4428 8584 2962 5729 5325 4370
[27] 5989 9030 5532 9623
```

or, if you have a narrower panel.

```{r eval=FALSE}
> distances
 [1]  687 5076 7270  967 6364 1683 9394
 [8] 5712 5206 4317 9411 5625 9725 4977
[15] 2730 5648 3818 8241 5547 1637 4428
[22] 8584 2962 5729 5325 4370 5989 9030
[29] 5532 9623
```

The numbers within the square brackets - `[1]`, `[8]`, `[15]`, and so on - tell us which _elements_ of the vector that are printed first on each row. So in the latter example, the first element in the vector is `687`, the 8th element is `5712`, the 15th element is `2730`, and so forth. Those numbers, called the _indices_ of the elements, aren't exactly part of your data, but as we'll see later they are useful for keeping track of it.

```{r eval=FALSE}
x <- 4
x
```

renders the output

```{r eval=FALSE}
> x
[1] 4
```

tells us that `x` in fact is a vector, albeit with a single element. Almost everything in R is a vector, in one way or another.

Being able to put data on multiple lines when creating vectors is hugely useful, but can also cause problems if you forget to include the closing bracket `)`. Try running the following code, where the final bracket is missing, in your Console panel:

```{r eval=FALSE}
distances <- c(687, 5076, 7270, 967, 6364, 1683, 9394, 5712, 5206,
               4317, 9411, 5625, 9725, 4977, 2730, 5648, 3818, 8241,
               5547, 1637, 4428, 8584, 2962, 5729, 5325, 4370, 5989,
               9030, 5532, 9623
```

When you hit Enter, a new line starting with a `+` sign appears. This indicates that R doesn't think that your statement has finished. To finish it, type `)` in the Console and then press Enter.

Vectors and data frames are hugely important when working with data in R.

#### Exercise
Do the following:
1. Create two vectors, `height` and `weight`, containing the heights and weights of five fictional people (i.e. just make up some numbers!).
2. Combine your two vectors into a data frame.
You will use these vectors in.
3. Try creating a vector using `x <- 1:5`. What happens? What happens if you use `5:1` instead? How can you use this notation to create the vector $(1,2,3,4,5,4,3,2,1)$?

## Vectors in data frames
In the next few sections, we will explore the `airquality` dataset. It contains daily air quality measurements from New York during a period of five months:

* `Ozone`: mean ozone concentration (ppb),
* `Solar.R`: solar radiation (Langley),
* `Wind`: average wind speed (mph),
* `Temp`: maximum daily temperature in degrees Fahrenheit,
* `Month`: numeric month (May=5, June=6, and so on),
* `Day`: numeric day of the month (1-31).

There are lots of things that would be interesting to look at in this dataset. What was the mean temperature during the period? Which day was the hottest? Which was the windiest? What days were the temperature more than 90 degrees Fahrenheit? To answer these questions, we need to be able to access the vectors inside the data frame. We also need to be able to quickly and automatically screen the data in order to find interesting observations (e.g. the hottest day)

### Accessing vectors and elements {#accessingelements}
In Section, we learned how to compute the mean of a vector. We also learned that to compute the mean of a vector _that is stored inside a data frame_ we could use a dollar sign: `data_frame_name$vector_name`. Here is an example with the `airquality` data:

```{r eval=FALSE}
# Extract the Temp vector:
airquality$Temp
# Compute the mean temperature:
mean(airquality$Temp)
```

If we want to grab a particular element from a vector, we must use its _index_ within square brackets: `[index]`. The first element in the vector has index 1, the second has index 2, the third index 3, and so on. To access the fifth element in the `Temp` vector in the `airquality` data frame, we can use:

```{r eval=FALSE}
airquality$Temp[5]
```

The square brackets can also be applied directly to the data frame. The syntax for this follows that used for matrices in mathematics: `airquality[i, j]` means the element at the i:th row and j:th column of `airquality`. We can also leave out either `i` or `j` to extract an entire row or column from the data frame. Here are some examples:

```{r eval=FALSE}
# First, we check the order of the columns:
names(airquality)
# We see that Temp is the 4th column.
airquality[5, 4]    # The 5th element from the 4th column,
                    # i.e. the same as airquality$Temp[5]
airquality[5,]      # The 5th row of the data
airquality[, 4]     # The 4th column of the data, like airquality$Temp
airquality[[4]]     # The 4th column of the data, like airquality$Temp
airquality[, c(2, 4, 6)] # The 2nd, 4th and 6th columns of the data
airquality[, -2]    # All columns except the 2nd one
airquality[, c("Temp", "Wind")] # The Temp and Wind columns
```

#### Exercise
The following tasks all involve using the the `[i, j]` notation for extracting data from data frames:
  
1. Why does `airquality[, 3]` not return the third row of `airquality`?
  
2. Extract the first five rows from `airquality`. 
_Hint:_ a fast way of creating the vector `c(1, 2, 3, 4, 5)` is to write `1:5`.
3. Compute the correlation between the `Temp` and `Wind` vectors of `airquality` without referring to them using `$`.
4. Extract all columns from `airquality` _except_ `Temp` and `Wind`.

### Use your dollars
The `$` operator can be used not just to extract data from a data frame, but also to manipulate it. Let's return to our `bookstore` data frame, and see how we can make changes to it using the dollar sign.

```{r eval=FALSE}
age <- c(28, 48, 47, 71, 22, 80, 48, 30, 31)
purchase <- c(20, 59, 2, 12, 22, 160, 34, 34, 29)
bookstore <- data.frame(age, purchase)
```

Perhaps there was a data entry error - the second customer was actually 18 years old and not 48. We can assign a new value to that element by referring to it in either of two ways:

```{r eval=FALSE}
bookstore$age[2] <- 18
# or
bookstore[2, 1] <- 18
```

We could also change an entire column if we like. For instance, if we wish to change the `age` vector to months instead of years, we could use
```{r eval=FALSE}
bookstore$age <- bookstore$age * 12
```

What if we want to add another variable to the data, for instance the length of the customers' visits in minutes? There are several ways to accomplish this, one of which involves the dollar sign:

```{r eval=FALSE}
bookstore$visit_length <- c(5, 2, 20, 22, 12, 31, 9, 10, 11)
bookstore
```

As you see, the new data has now been added to a new column in the data frame.

#### Exercise
Use the `bookstore` data frame to do the following:
  
1. Add a new variable `rev_per_minute` which is the ratio between purchase and the visit length.
2. Replace the purchase amount for the 80-year old customer with `16`.


### Using conditions 
A few paragraphs ago, we were asking which was the hottest day in the `airquality` data. Let's find out! We already know how to find the maximum value in the `Temp` vector:

```{r eval=FALSE}
max(airquality$Temp)
```

But can we find out which day this corresponds to? We could of course manually go through all 153 days e.g. by using `View(airquality)`, but that seems tiresome and wouldn't even be possible in the first place if we'd had more observations. A better option is therefore to use the function `which.max`:

```{r eval=FALSE}
which.max(airquality$Temp)
```

`which.max` returns the index of the observation with the maximum value. If there is more than one observation attaining this value, it only returns the first of these.

We've just used `which.max` to find out that day `120` was the hottest during the period. If we want to have a look at the entire row for that day, we can use

```{r eval=FALSE}
airquality[120,]
```

Alternatively, we could place the call to `which.max` inside the brackets. Because `which.max(airquality$Temp)` returns the number `120`, this yields the same result as the previous line:

```{r eval=FALSE}
airquality[which.max(airquality$Temp),]
```

Were we looking for the day with the lowest temperature, we'd use `which.min` analogously. In fact, we could use any function or computation that returns an index in the same way, placing it inside the brackets to get the corresponding rows or columns. This is extremely useful is we want to extract observations with certain properties, for instance all days where the temperature was above 90 degrees. We do this using _conditions_, i.e. by giving statements that we wish to be fulfilled.

As a first example of a condition, we use the following, which checks if the temperature exceeds 90 degrees:

```{r eval=FALSE}
airquality$Temp > 90
```

For each element in `airquality$Temp` this returns either `TRUE` (if the condition is fulfilled, i.e. when the temperature is greater than 90) or `FALSE` (if the conditions isn't fulfilled, i.e. when the temperature is 90 or lower). If we place the condition inside brackets following the name of the data frame, we will extract only the rows corresponding to those elements which were marked with `TRUE`:

```{r eval=FALSE}
airquality[airquality$Temp > 90, ]
```

If you prefer, you can also store the `TRUE` or `FALSE` values in a new variable:

```{r eval=FALSE}
airquality$Hot <- airquality$Temp > 90
```

There are several logical operators and functions which are useful when stating conditions in R:

```{r eval=FALSE}
a <- 3
b <- 8
a == b     # Check if a equals b
a > b      # Check if a is greater than b
a < b      # Check if a is less than b
a >= b     # Check if a is equal to or greater than b
a <= b     # Check if a is equal to or less than b
a != b     # Check if a is not equal to b
is.na(a)   # Check if a is NA
a %in% c(1, 4, 9) # Check if a equals at least one of 1, 4, 9
```  

When checking a conditions for all elements in a vector, we can use `which` to get the indices of the elements that fulfill the condition:

```{r eval=FALSE}
which(airquality$Temp > 90)
```  

If we want to know if all elements in a vector fulfill the condition, we can use `all`

```{r eval=FALSE}
all(airquality$Temp > 90)
```  

In this case, it returns `FALSE`, meaning that not all days had a temperature above 90 (phew!). Similarly, if we wish to know whether _at least one_ day had a temperature above 90, we can use `any`:

```{r eval=FALSE}
any(airquality$Temp > 90)
```

To find how many elements that fulfill a condition, we can use `sum`:

```{r eval=FALSE}
sum(airquality$Temp > 90)
```

Why does this work? Remember that `sum` computes the sum of the elements in a vector, and that when `logical` values are used in computations, they are treated as `0` (`FALSE`) or `1` (`TRUE`). Because the condition returns a vector of `logical` values, the sum of them becomes the number of 1's - the number of `TRUE` values  - i.e. the number of elements that fulfill the condition.

To find the proportion of elements that fulfill a condition, we can count how many elements fulfill it and then divide by how many elements are in the vector. This is exactly what happens if we use `mean`:

```{r eval=FALSE}
mean(airquality$Temp > 90)
```

Finally, we can combine conditions by using the logical operators `&` (AND), `|` (OR). Here are some examples:

```{r eval=FALSE}
a <- 3
b <- 8
# Is a less than b and greater than 1?
a < b & a > 1
# Is a less than b and equal to 4?
a < b & a == 4
# Is a less than b and/or equal to 4?
a < b | a == 4
# Is a equal to 4 and/or equal to 5?
a == 4 | a == 5
```


#### Exercise
The following tasks all involve checking conditions for the `airquality` data:
  
1. Which was the coldest day during the period?
  
2. How many days was the wind speed greater than 17 mph?
  
3. How many missing values are there in the `Ozone` vector?
  
4. How many days are there for which the temperature was below 70 and the wind speed was above 10?

